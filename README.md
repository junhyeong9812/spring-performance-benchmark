# Spring MVC vs WebFlux Performance Benchmark

Spring Boot 4.0 + Java 25 기반 Tomcat MVC와 Netty WebFlux 성능 비교 프로젝트

## 📋 프로젝트 개요

이 프로젝트는 동일한 비즈니스 로직을 가진 두 개의 Spring 애플리케이션을 통해:
- **Spring MVC (Tomcat)**: 전통적인 Servlet 기반 동기 처리
- **Spring WebFlux (Netty)**: Reactive 기반 비동기 처리

대용량 트래픽 환경에서의 성능 차이를 측정하고 분석합니다.

## 🏛️ 테스트 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  Server PC (A) - Docker Compose                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                         Nginx (Reverse Proxy)                         │  │
│  │                              Port: 80                                 │  │
│  │                    /mvc/* → mvc-app:8080                              │  │
│  │                    /webflux/* → webflux-app:8081                      │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│          │                              │                                   │
│          ▼                              ▼                                   │
│  ┌───────────────────┐        ┌───────────────────┐                        │
│  │     mvc-app       │        │   webflux-app     │                        │
│  │   (Container)     │        │   (Container)     │                        │
│  │                   │        │                   │                        │
│  │ CPU: 2 cores      │        │ CPU: 2 cores      │                        │
│  │ Memory: 1GB       │        │ Memory: 1GB       │                        │
│  │ Port: 8080        │        │ Port: 8081        │                        │
│  └───────────────────┘        └───────────────────┘                        │
│          │                              │                                   │
│          └──────────────┬───────────────┘                                   │
│                         ▼                                                   │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                    Monitoring Stack                                   │  │
│  │  ┌─────────────┐              ┌─────────────┐                        │  │
│  │  │ Prometheus  │─────────────▶│  Grafana    │                        │  │
│  │  │ Port: 9090  │              │ Port: 3000  │                        │  │
│  │  └─────────────┘              └─────────────┘                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ▲
                                    │ HTTP Requests
                                    │
┌─────────────────────────────────────────────────────────────────────────────┐
│  Client PC (B) - Load Test                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                              k6                                       │  │
│  │                                                                       │  │
│  │  k6 run --env TARGET_HOST=<SERVER_IP> scenarios/load-test.js         │  │
│  │                                                                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 테스트 환경 구성

| 구성 요소 | 위치 | 역할 |
|----------|------|------|
| Docker Compose | Server PC (A) | MVC/WebFlux 앱 + 모니터링 스택 |
| Nginx | Server PC (A) | 리버스 프록시, 단일 진입점 |
| k6 | Client PC (B) | 부하 생성 (서버와 분리) |

### 로컬 테스트 (1대 PC)
- k6에서 `TARGET_HOST=localhost` 또는 `TARGET_HOST=127.0.0.1` 지정
- Nginx 포트(80)로 요청

### 원격 테스트 (2대 PC - 권장)
- Server PC에서 Docker Compose 실행
- Client PC에서 `TARGET_HOST=<SERVER_IP>` 지정하여 k6 실행

